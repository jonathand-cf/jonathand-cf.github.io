---
title: "How I Built a Wireless Air Mouse from Scratch"
categories: tutorials
open_new_tab: true
toc_sticky: true
author_profile: true
toc: true
---

This post is under construction and is not complete.

---

So, my living room setup is basically a ROG Ally hooked up to my TV. It's great for media, but controlling it has been a real pain. I've been using [Unified Remote](https://www.unifiedremote.com/) on my phone, but between my PC's IP address changing and just having to find my phone, it's more hassle than it's worth. I just wanted a simple, dedicated controller.

Then, while doom scrolling Instagram, I stumbled upon a super cool air mouse someone had built. It was a lightbulb moment. I realized I had most of the parts allready, an ESP32, buttons, an OLED screen, just lying around. All I needed was a gyroscope. This project was inspired by that project [Air Mouse (Version 2.0)](https://github.com/udit1567/Circuit_forge/tree/main/Air%20Mouse/Version%201.0) by udit1567.

**Full build found at [Github](https://github.com/jonathand-cf/AirPoint)**

Here's how I built my own version from scratch.

## The Requirements

- **Arduino IDE**: [Arduino IDE](https://www.arduino.cc/en/software/)  

- **OLED I2C**: [OLED I2C SSD1315 LCD](https://www.aliexpress.com/item/1005007550156148.html)

- **STM32 WROOM-32**: [ESP32 Development Board (ESP-WROOM-32)](https://www.aliexpress.com/item/1005006128432036.html)

- **Gyroscope**: [GY-521 MPU6050 3-Axis Accelerometer Gyro Module](https://www.aliexpress.com/item/1005008472252705.html)

- **Breadboard and cables**

---

## The Build Process

While waiting for the gyroscope to arrive in the mail, I started the first iteration of the project. This involved setting up the ESP32 with the OLED screen and the buttons. The goal was to have a basic interface and ensure all the components were working together before integrating the motion controls.

### Hardware

Here is an early test of the OLED screen displaying button presses and the BLE connection status.

![Initial test of the ESP32 with OLED screen and button inputs](/assets/images/IMG_0435.jpg)

Here's how the components were wired up on the breadboard for these initial tests.

![Circuit diagram for the initial breadboard setup](/assets/images/circuit_image.png)

After finalizing the design, the gyroscope was integrated and all components were assembled into the finished 3D-printed case.

### 3D Case

A custom 3D-printed case is also in the works to house all the components neatly. This project has been a great opportunity to learn Onshape for 3D modeling. It's a powerful tool, but there's definitely a learning curve. I ran into a few design challenges, like this one, but it's all part of the process.

![An error encountered during the 3D modeling process in Onshape](/assets/images/ErrorAirMouse.png)

The design started with a basic sketch to map out the component placement.

![Initial Onshape sketch for the Air Mouse case](/assets/images/SKETCHEARLY.png)

And here are some of the first successful prints of the case components. The design is still being finalized, and I'm excited to share the progress on that once it's ready.

![Early 3D printed parts for the Air Mouse case](/assets/images/IMG_0431.jpg)
![More 3D printed parts for the Air Mouse case](/assets/images/IMG_0434.jpg)

## The Code

The heart of this project is the Arduino code running on the ESP32. It handles everything from reading button inputs to communicating with the computer via Bluetooth. Let's break down how it works.

### Core Libraries

The code relies on a few key libraries to function:

- `BleMouse.h`: This library turns the ESP32 into a Bluetooth Low Energy (BLE) mouse, allowing it to connect to any computer wirelessly.
- `U8g2lib.h`: Used to control the OLED display for showing connection status and other messages.
- `Wire.h`: Handles I2C communication for the OLED display.

```cpp
#include <BleMouse.h>
#include <U8g2lib.h>
#include <Wire.h>
```

### Board Manager

- `esp32`: espressif esp32 library (v. 2.0.17)

### Setup and Initialization

In the `setup()` function, we initialize all the components:

1. **I2C and OLED Display**: The `Wire.begin()` call starts the I2C communication protocol, which the OLED screen uses. The `u8g2.begin()` initializes the display, and a helper function `showStatus()` is used to display messages.
2. **Buttons**: The four push-buttons for left-click, right-click, scroll-up, and scroll-down are configured as inputs. External pull-up resistors are used.
3. **BLE Mouse**: Finally, `bleMouse.begin()` starts the Bluetooth service, making the device discoverable as "ESP32 BLE Mouse".

```cpp
void setup() {
  // I2C + OLED
  Wire.begin();  // SDA=21, SCL=22 (default)
  u8g2.begin();
  showStatus("Connecting...");

  // Buttons
  pinMode(LEFT_CLICK_PIN, INPUT);  // external pull-ups on your keypad board
  pinMode(RIGHT_CLICK_PIN, INPUT);
  pinMode(SCROLL_UP_PIN, INPUT);
  pinMode(SCROLL_DOWN_PIN, INPUT);

  // BLE
  bleMouse.begin();
}
```

### The Main Loop: Bringing It All Together

The `loop()` function is where the magic happens.

1. **Connection Status**: It first checks if the mouse is connected via Bluetooth. The OLED screen is updated to show "Connected" or "Not connected," which is a handy visual indicator.

2. **Button Handling**: The code continuously checks the state of the four buttons. A simple debouncing mechanism is included to prevent a single physical press from registering as multiple clicks. Based on which button is pressed, it sends a left-click, right-click, or scroll wheel command over Bluetooth.

3. **Testing Movement**: When `TEST_MOVE` is enabled, the mouse cursor moves automatically for testing purposes.

```cpp
void loop() {
  bool connected = bleMouse.isConnected();

  // Update OLED when connection state changes
  if (connected != lastConnected) {
    showStatus(connected ? "Connected" : "Not connected");
    lastConnected = connected;
  }

  // --- Buttons ---
  bool l = readBtn(bL);
  bool r = readBtn(bR);
  bool u = readBtn(bU);
  bool d = readBtn(bD);

  // Left click
  //...//

  // Right click
  //...//

  // Scroll (repeat)
  uint32_t now = millis();
  static uint32_t lastScroll = 0;
  const uint16_t scrollPeriodMs = 120;
  if (u == LOW && now - lastScroll > scrollPeriodMs) {
    bleMouse.move(0, 0, +1);
    lastScroll = now;
  }
  if (d == LOW && now - lastScroll > scrollPeriodMs) {
    bleMouse.move(0, 0, -1);
    lastScroll = now;
  }

  delay(5);
}
```

This loop runs continuously, creating a smooth and responsive experience.
