---
title: "How I Built a Wireless Mouse Pointer from Scratch"
categories: tutorials
open_new_tab: true
toc_sticky: true
author_profile: true
toc: true
---

So, my living room setup is basically a ROG Ally hooked up to my TV. It's great for media, but controlling it has been a real pain. I've been using [Unified Remote](https://www.unifiedremote.com/) on my phone, but between my PC's IP address changing and just having to find my phone, it's more hassle than it's worth. I just wanted a simple, dedicated controller.

Then, while doom scrolling Instagram, I stumbled upon a super cool air mouse someone had built. It was a lightbulb moment. I realized I had most of the parts allready, an ESP32, buttons, an OLED screen, just lying around. All I needed was a gyroscope. This project was inspired by that project [Air Mouse (Version 2.0)](https://github.com/udit1567/Circuit_forge/tree/main/Air%20Mouse/Version%201.0) by udit1567.

**Full build found at [Github](https://github.com/jonathand-cf/AirPoint)**

Here's how I built my own version from scratch.

## The Requirements

### Hardware Requrements

- **Arduino IDE**: [Arduino IDE](https://www.arduino.cc/en/software/)  

- **OLED I2C**: [OLED I2C SSD1315 LCD](https://www.aliexpress.com/item/1005007550156148.html)

- **ESP32 WROOM-32**: [ESP32 Development Board (ESP-WROOM-32)](https://www.aliexpress.com/item/1005006128432036.html)

- **Gyroscope**: [GY-521 MPU6050 3-Axis Accelerometer Gyro Module](https://www.aliexpress.com/item/1005008472252705.html)

- **4× Push buttons** (comes with the OLED I2C i linked)

- **Breadboard for testing and jumper wires**

### Software Libraries

Install these via the Arduino Library Manager:

- **BleMouse**: BLE HID mouse support
- **U8g2**: OLED display control
- **MPU6050_tockn**: MPU6050 sensor interface
- **Wire**: I2C communication (built-in)

---

## The Build Process

While waiting for the gyroscope to arrive in the mail, I started the first iteration of the project. This involved setting up the ESP32 with the OLED screen and the buttons. The goal was to have a basic interface and ensure all the components were working together before integrating the motion controls.

### Hardware

Here is an early test of the OLED screen displaying button presses and the BLE connection status.

![Initial test of the ESP32 with OLED screen and button inputs](/assets/images/IMG_0435.jpg)

Here's how the components were wired up on the breadboard for these initial tests.

![Circuit diagram for the initial breadboard setup](/assets/images/circuit_image.png)

After finalizing the design, the gyroscope was integrated and all components were assembled into the finished 3D-printed case.

### 3D Case

A custom 3D-printed case is also in the works to house all the components neatly. This project has been a great opportunity to learn Onshape for 3D modeling. It's a powerful tool, but there's definitely a learning curve. I ran into a few design challenges, like this one, but it's all part of the process.

![An error encountered during the 3D modeling process in Onshape](/assets/images/ErrorAirMouse.png)

The design started with a basic sketch to map out the component placement.

![Initial Onshape sketch for the Air Mouse case](/assets/images/SKETCHEARLY.png)

And here are some of the first successful prints of the case components. The design is still being finalized, and I'm excited to share the progress on that once it's ready.

![Early 3D printed parts for the Air Mouse case](/assets/images/IMG_0431.jpg)
![More 3D printed parts for the Air Mouse case](/assets/images/IMG_0434.jpg)

## The Code

The heart of this project is the Arduino code running on the ESP32. It handles everything from reading button inputs to communicating with the computer via Bluetooth. Let's break down how it works.

### Core Libraries

The code relies on several key libraries:

- `BleMouse.h`: Turns the ESP32 into a Bluetooth Low Energy (BLE) HID mouse, allowing wireless connection to any computer.
- `U8g2lib.h`: Controls the OLED display for showing connection status and messages.
- `MPU6050_tockn.h`: Interfaces with the MPU6050 gyroscope/accelerometer for motion tracking.
- `Wire.h`: Handles I2C communication for both the OLED and MPU6050.
- `math.h`: Provides mathematical functions for sensor fusion calculations.

```cpp
#include <Wire.h>
#include <BleMouse.h>
#include <MPU6050_tockn.h>
#include <U8g2lib.h>
#include <math.h>
```

### Board Manager

- `esp32`: espressif esp32 library (v. 2.0.17)

### Setup and Initialization

The `setup()` function initializes all components with careful attention to the dual I2C bus configuration:

1. **Dual I2C Buses**: 
   - Primary I2C (Wire) for the OLED on GPIO21 (SDA) and GPIO22 (SCL)
   - Secondary I2C (I2C_MPU) for the MPU6050 on GPIO4 (SDA) and GPIO16 (SCL)
   - This separation prevents bus conflicts and improves reliability

2. **OLED Display**: Initialized with `u8g2.begin()` and displays boot status messages

3. **I2C Scanner**: Runs diagnostic scan on both buses to verify devices are detected (helpful for troubleshooting)

4. **MPU6050**: Initialized and calibrated with `mpu.calcGyroOffsets(true)` to establish baseline gyro readings

5. **Buttons**: Configured with internal pull-ups (`INPUT_PULLUP`) - no external resistors needed!

6. **BLE Mouse**: Started with `bleMouse.begin()`, advertising as "ESP32 BLE Mouse"

7. **Initial Orientation**: Reads current tilt angles and sets them as the neutral position

```cpp
void setup() {
  Serial.begin(115200);
  
  // Init I2C buses
  Wire.begin(SDA_OLED, SCL_OLED);        // GPIO21, GPIO22
  I2C_MPU.begin(SDA_MPU, SCL_MPU);       // GPIO4, GPIO16
  
  // OLED
  u8g2.begin();
  showStatus("Booting...");
  
  // Verify devices (optional but helpful)
  scanI2C(Wire, "OLED bus (Wire)");
  scanI2C(I2C_MPU, "MPU bus (I2C_MPU)");
  
  // MPU6050
  mpu.begin();
  mpu.calcGyroOffsets(true);
  
  // BLE
  bleMouse.begin();
  showStatus("Connecting...");
  
  // Buttons with internal pull-ups
  pinMode(LEFT_CLICK_PIN, INPUT_PULLUP);
  pinMode(RIGHT_CLICK_PIN, INPUT_PULLUP);
  pinMode(SCROLL_UP_PIN, INPUT_PULLUP);
  pinMode(SCROLL_DOWN_PIN, INPUT_PULLUP);
  
  // Set initial neutral orientation
  mpu.update();
  float ax = mpu.getAccX();
  float ay = mpu.getAccY();
  float az = mpu.getAccZ();
  
  rollDeg = atan2f(ay, az) * RAD2DEG;
  pitchDeg = atan2f(-ax, sqrtf(ay*ay + az*az)) * RAD2DEG;
  neutralRollDeg = rollDeg;
  neutralPitchDeg = pitchDeg;
}
```

### The Main Loop: Bringing It All Together

The `loop()` function orchestrates all functionality in real-time:

#### 1. Connection Status

Checks BLE connection and updates the OLED display. When connection is established, it automatically recenters the cursor neutral position.

#### 2. Button Handling with Debouncing

All four buttons are debounced (25ms) to prevent false triggers:

- **Left/Right Click**: Press and hold detection with visual feedback
- **Scroll Up/Down**: Rate-limited to 120ms intervals for smooth scrolling
- **Manual Recenter**: Hold both left and right buttons for 800ms to reset the neutral orientation

#### 3. Motion Tracking with Complementary Filter

This is where the air mouse magic happens:

**Sensor Fusion**: Combines gyroscope and accelerometer data using a complementary filter (α=0.98) to get smooth, drift-free orientation:

```cpp
// Gyroscope integration
rollDeg += gx * dt;
pitchDeg += gy * dt;

// Complementary filter blends gyro and accelerometer
rollDeg = alpha * rollDeg + (1.0f - alpha) * rollAccDeg;
pitchDeg = alpha * pitchDeg + (1.0f - alpha) * pitchAccDeg;
```

**Deadzone & Sensitivity**: A 1.0° deadzone eliminates jitter when holding still. Tilt angles are converted to cursor velocity with configurable speed scaling (35 units/degree, max 900).

**Auto-Calibration**: When the device is held still for 900ms (detected by low gyro activity and stable accelerometer), it automatically recalibrates gyro offsets to eliminate drift.

```cpp
void loop() {
  bool connected = bleMouse.isConnected();
  
  // Auto-recenter on connect
  if (connected != lastConnected) {
    showStatus(connected ? "Connected" : "Not connected");
    lastConnected = connected;
    if (connected) {
      mpu.update();
      recenterNeutral();
    }
  }
  
  // Read debounced buttons
  bool l = readBtn(bL);
  bool r = readBtn(bR);
  bool u = readBtn(bU);
  bool d = readBtn(bD);
  
  // Manual recenter: hold L+R for 800ms
  if (l == LOW && r == LOW) {
    if (recenterStartMs == 0) recenterStartMs = millis();
    if (millis() - recenterStartMs > 800) {
      recenterNeutral();
      recenterStartMs = 0;
    }
  } else {
    recenterStartMs = 0;
  }
  
  // Click handling with press/release
  if (l == LOW && !bleMouse.isPressed(MOUSE_LEFT)) {
    bleMouse.press(MOUSE_LEFT);
  } else if (l == HIGH && bleMouse.isPressed(MOUSE_LEFT)) {
    bleMouse.release(MOUSE_LEFT);
    showStatus("Left Click");
  }
  
  // Update MPU and apply complementary filter
  mpu.update();
  float dt = (millis() - lastIMUms) * 0.001f;
  
  float gx = mpu.getGyroX();
  float gy = mpu.getGyroY();
  float ax = mpu.getAccX();
  float ay = mpu.getAccY();
  float az = mpu.getAccZ();
  
  // Sensor fusion
  rollDeg += gx * dt;
  pitchDeg += gy * dt;
  rollDeg = alpha * rollDeg + (1.0f - alpha) * atan2f(ay, az) * RAD2DEG;
  pitchDeg = alpha * pitchDeg + (1.0f - alpha) * atan2f(-ax, sqrtf(ay*ay + az*az)) * RAD2DEG;
  
  // Calculate cursor movement with deadzone
  float dRoll = applyDeadzone(rollDeg - neutralRollDeg, 1.0f);
  float dPitch = applyDeadzone(pitchDeg - neutralPitchDeg, 1.0f);
  
  int dx = (int)clampf(dRoll * 35.0f * dt, -127, 127);
  int dy = (int)clampf(dPitch * 35.0f * dt, -127, 127);
  
  if (connected && (dx != 0 || dy != 0)) {
    bleMouse.move(-dx, dy);
  }
  
  delay(5);
}
```

This loop runs continuously at ~200Hz, providing smooth and responsive cursor control.

## Key Features

### Complementary Filter

The complementary filter is crucial for smooth motion tracking. It combines the best of both sensors:

- **Gyroscope**: Excellent short-term accuracy but drifts over time
- **Accelerometer**: Stable long-term but noisy in the short term

With α=0.98, we trust the gyroscope 98% and use the accelerometer 2% to correct drift.

### Auto-Calibration

Gyroscopes naturally drift. The auto-calibration feature detects when you're holding the device still (less than 1.2°/s rotation and stable gravity vector) and recalibrates the zero-point after 900ms. This happens transparently in the background.

### Manual Recenter

Sometimes you need to quickly reset your neutral position. Hold both left and right click buttons together for 800ms, and the current orientation becomes your new center point. Perfect for adjusting your grip mid-session.

### Debouncing

All buttons use a 25ms software debounce to prevent switch bounce from registering as multiple clicks. This ensures clean, reliable button presses.

## Pin Configuration

| Component | Pin | GPIO |
|-----------|-----|------|
| OLED SDA | SDA | 21 |
| OLED SCL | SCL | 22 |
| MPU6050 SDA | IO4 | 4 |
| MPU6050 SCL | IO16 | 16 |
| Left Click | IO18 | 18 |
| Right Click | IO19 | 19 |
| Scroll Up | IO5 | 5 |
| Scroll Down | IO17 | 17 |

## Final Thoughts

Building this air mouse was a fantastic learning experience. The combination of BLE HID, sensor fusion, and 3D printing created a genuinely useful tool for controlling my ROG Ally from the couch. The automatic features like drift compensation and recenter-on-connect make it feel polished and professional.

The full code and 3D models are available on [GitHub](https://github.com/jonathand-cf/AirPoint). Feel free to build your own or suggest improvements!
